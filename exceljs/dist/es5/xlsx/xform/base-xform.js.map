{"version":3,"sources":["../../../../lib/xlsx/xform/base-xform.js"],"names":["parseSax","require","XmlStream","BaseXform","node","text","name","model","options","map","Object","values","forEach","xform","reset","obj","assign","saxParser","events","eventType","value","parseOpen","parseText","parseClose","stream","parse","toXml","xmlStream","render","xml","dflt","always","undefined","toString","toAttribute","attr","parseInt","parseFloat","module","exports"],"mappings":"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","sourcesContent":["const parseSax = require('../../utils/parse-sax');\nconst XmlStream = require('../../utils/xml-stream');\n\n/* 'virtual' methods used as a form of documentation */\n/* eslint-disable class-methods-use-this */\n\n// Base class for Xforms\nclass BaseXform {\n  // constructor(/* model, name */) {}\n\n  // ============================================================\n  // Virtual Interface\n  prepare(/* model, options */) {\n    // optional preparation (mutation) of model so it is ready for write\n  }\n\n  render(/* xmlStream, model */) {\n    // convert model to xml\n  }\n\n  parseOpen(node) {\n    // XML node opened\n  }\n\n  parseText(text) {\n    // chunk of text encountered for current node\n  }\n\n  parseClose(name) {\n    // XML node closed\n  }\n\n  reconcile(model, options) {\n    // optional post-parse step (opposite to prepare)\n  }\n\n  // ============================================================\n  reset() {\n    // to make sure parses don't bleed to next iteration\n    this.model = null;\n\n    // if we have a map - reset them too\n    if (this.map) {\n      Object.values(this.map).forEach(xform => {\n        if (xform instanceof BaseXform) {\n          xform.reset();\n        } else if (xform.xform) {\n          xform.xform.reset();\n        }\n      });\n    }\n  }\n\n  mergeModel(obj) {\n    // set obj's props to this.model\n    this.model = Object.assign(this.model || {}, obj);\n  }\n\n  async parse(saxParser) {\n    for await (const events of saxParser) {\n      for (const {eventType, value} of events) {\n        if (eventType === 'opentag') {\n          this.parseOpen(value);\n        } else if (eventType === 'text') {\n          this.parseText(value);\n        } else if (eventType === 'closetag') {\n          if (!this.parseClose(value.name)) {\n            return this.model;\n          }\n        }\n      }\n    }\n    return this.model;\n  }\n\n  async parseStream(stream) {\n    return this.parse(parseSax(stream));\n  }\n\n  get xml() {\n    // convenience function to get the xml of this.model\n    // useful for manager types that are built during the prepare phase\n    return this.toXml(this.model);\n  }\n\n  toXml(model) {\n    const xmlStream = new XmlStream();\n    this.render(xmlStream, model);\n    return xmlStream.xml;\n  }\n\n  // ============================================================\n  // Useful Utilities\n  static toAttribute(value, dflt, always = false) {\n    if (value === undefined) {\n      if (always) {\n        return dflt;\n      }\n    } else if (always || value !== dflt) {\n      return value.toString();\n    }\n    return undefined;\n  }\n\n  static toStringAttribute(value, dflt, always = false) {\n    return BaseXform.toAttribute(value, dflt, always);\n  }\n\n  static toStringValue(attr, dflt) {\n    return attr === undefined ? dflt : attr;\n  }\n\n  static toBoolAttribute(value, dflt, always = false) {\n    if (value === undefined) {\n      if (always) {\n        return dflt;\n      }\n    } else if (always || value !== dflt) {\n      return value ? '1' : '0';\n    }\n    return undefined;\n  }\n\n  static toBoolValue(attr, dflt) {\n    return attr === undefined ? dflt : attr === '1';\n  }\n\n  static toIntAttribute(value, dflt, always = false) {\n    return BaseXform.toAttribute(value, dflt, always);\n  }\n\n  static toIntValue(attr, dflt) {\n    return attr === undefined ? dflt : parseInt(attr, 10);\n  }\n\n  static toFloatAttribute(value, dflt, always = false) {\n    return BaseXform.toAttribute(value, dflt, always);\n  }\n\n  static toFloatValue(attr, dflt) {\n    return attr === undefined ? dflt : parseFloat(attr);\n  }\n}\n\nmodule.exports = BaseXform;\n"],"file":"base-xform.js"}